一、工厂方法模式（Factory Method）：
    工厂模式分为3中：
    1.普通工厂模式，就是建立一个工厂类，对实现了同一个接口的一些类进行实例的创建。
        1).首先创建两个类的共同接口Sender()
        2).其次创建实现类MailSender(),SmsSender()
        3).创建工厂类
    2.多个工厂方法模式，是多哦普通工厂模式的改进，在普通工厂模式中，如果传递的字符串出错，则不能正确创建对象，
        而多个工厂方法模式提供多个工厂模式，分别创建对象。
        步骤同上。
    3.静态工厂方法模式，将上述多个工厂模式里的方法设置为静态的，不需要创建实例，直接调用即可。
二、抽象工厂类（Abstract Factory）：
    工厂方法模式有一个问题，类的创建依赖于工厂类。也就是说想要拓展类，就必须要修改工厂类，这违反了闭包原则。
    抽象工厂解决了这个问题，抽象工厂模式创建多个工厂，这样需要增加新的功能时，只需要再创建一个工厂类就可以了，不需要修改之前的代码。
    1.首先创建共同的接口Sender();
    2.创建两个Sender()的实现类MailSender(),SmsSender();
    3.为工厂类提供一个接口Provider();
    4.创建两个Provider()的实现类SendMailFactory(),SendSmsFactory().
    这样做的好处是，要添加一个新的功能，只需要创建一个Sender()的实现类和一个Provider()的实现类（这个类是工厂类）。
    这样做，有较好的拓展性。

三、单例模式（Singleton）：
    单例模式是一种常见的设计模式，通过单例模式可以保证某对象的JVM中同一时刻只能有一个实例化对象。
    好处：
    1.某些类创建比较频繁，对于一些比较大的对象， 这是一笔很大的开销。
    2.省去了new的操作，降低了系统内存的使用频率，减小了GC的压力。
    3.有些类创建多了会造成混乱。
    单例模式中，使用private限定构造方法，使得Singleton的唯一实例只能通过getInstance()访问。
    分类：
    1.懒汉模式，在第一次调用的时候实例化自己；
    2.饿汉模式，在类初始化的时候已经进行了实例化。
四、创建者模式（Builder）：
    在软件系统的设计过程中，有时候面临“复杂系统”的创建工作，该对象通常由各个部分的子对象用一定的算法构成，或者按照一定的步骤组合而成；
    这些算法或者步骤是固定的，但是构成该对象的子对象却经常因需求的变化而变化。
    组成部分：
    1.Product：要创建的对象；
    2.Builder：为创建Product对象指定抽象接口；
    3.ConcreteBuilder：实现具体的构建算法；
    4.Director：提供构建Product对象的步骤顺序，即按照一定的顺序调用ConcreteBuilder的方法。
    优点：
    首先，建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，
    因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。
    其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，
    因此也就不会对原有功能引入风险。
